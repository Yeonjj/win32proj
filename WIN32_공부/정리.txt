# win32 

윈도우에서는 보ㅗㅇ struct을 파라미터로 받아서 설정을 한다. 


윈도우에서 entry point 는 winmain인데 이 함수는 실재로 c 런타임 라이브러리에서 부르는 함수 이다. 운영체제가 부를 함수가 아니다. 


#인스턴스 

win32에서 인스턴스는 프로그램의 실체로서 하드디스크에는 프로그램이 하나지만 막상 실행되있는 실체는 여러개가 될 수 있다. 이것이 인스턴스이다. 


HINSTANCE 는 구조체포인터로 쓰지않는 int 멤버를 가지고 있다. 이는 단순이 HANDLE에 할당됬을때 오류를 내밷기 위함이다. 
HINSTANCE 의 의미는 그프로그램의 핸들값을 의미한다. 
그리고 그 프로그램이 가지는 여러개의 윈도우를 구분하는 것이 HAND hWnd 이다.

excutable 이미지의 베이스 주소를 가리키고있다. 리소들을 로드할 때 사용한다. 


HANDLE은 void 포인터이다. 
이는 운영체제에의해 생성된 리소스나 오브젝트를 32bit의 정수값으로 제어하는 것이다. 따라서 포인터라기 보다는 32bit 정수값으로 보는것이 맞다.

다른 핸들을을 각기 다른 타입을 갖게하기 위함이다.

 
일단 핸들은 정수값이며 대부분의 경우 32비트값이다. 핸들을 사용하는 목적은 오로지 구분을 위한 것이므로 핸들끼리 중복되지 않아야하며 이런 목적으로는 정수형이 가장 적합하다.

핸들은 여러종류가 있다. 같은 종류의 핸들은 같은 핸들값을 가질 수 없다. 다른 종류라면 가능하다.
       

#WndProc
WndProc은 실체로 호출되는 것이 코드상에 보이지않는다. 
이유는 윈도우에서 호출하기때문이다. 

먼저 윈도우에서 인풋을 받으면 메시지큐로 메시지가 들어온다. 윈도우os 에서는 이를 getMessage함수로 프로그램에서 호출할 수있도록 user32.dll 동적라이브러리에 넣어두었다. 

이제 이 윈도우에 있는 메시지 큐에서 사용자의 인풋 메시지를 받으려면 getMessage를 사용해서 받아오면된다. 큐라는 것은 사용자가 입력한데로 그대로 뽑겠다는 의미이다. 

이렇게 메시지를 받아서 프로그램에서 메시지 자체를 가공한다. 그 뒤에 dispatchMessage를 호출하면 다시 메시지를 윈도우os로 보내고 윈도우 os에서는 이 메지지를 wndclasss를 통해 보내준

wndproc함수의 인자로 넘겨주며 이를 호출한다. 이것이 win32에서 메시지를 다루는 과정이다. 

아래는 내가 가젔던 의문에 대한 해답이다.  

Couldn't Windows just go ahead and dispatch all these messages itself? In principle it could, but a message loop gives your program a chance to have a peek at them and maybe perform some additional actions before dispatching them

그러고 보면 어째서wndproc에서 특정 윈도우의 핸들을 인자로 받아 오는지 알 수 있다. 그이유는 윈도우 os에서 특정 윈도우로 메시지를 전달하려는 의도인 것같다. 다만 이것을 프로그램에서 어떤 윈도우로 보내야
될지를 알려주어야 할 것같은데 윈도우os에서 호출한다는 것이 조금 의아하다. 

분명 특정윈도우로 메시지를 보내는 방법이 있을 것 같다.

그래서 프로그램에 두개의 윈도우가 있다면 한쪽에서 인풋이 다른 윈도우로 전달 되게끔 할 수 있을 것 같다. 

윈도우os에서 wndproc으로 메시지를 넘겨줄 때는 먼저 해당 윈도우의 클래스를 확인하고 연관된 wndproc을 찾는다. 그리고 wndproc을 호출한다.  

#타입들 

L이 붙은 타입 유니코드는 char를 사용하지만 멀티바이트에서는 WCHAR를 사용한다. 

   
